{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"spring boot 入门","slug":"spring-boot-入门","date":"2020-09-02T01:57:01.000Z","updated":"2020-09-02T02:10:48.165Z","comments":true,"path":"2020/09/02/spring-boot-入门/","link":"","permalink":"http://yoursite.com/2020/09/02/spring-boot-%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service12345678910@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;Hello World!&quot;; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目123456789101112131415&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；","categories":[],"tags":[]},{"title":"java后端知识体系","slug":"java后端知识体系","date":"2020-08-28T08:34:03.000Z","updated":"2020-08-28T08:34:53.715Z","comments":true,"path":"2020/08/28/java后端知识体系/","link":"","permalink":"http://yoursite.com/2020/08/28/java%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"今天转载一下java后端知识总结吧，由于这些天搬砖很累，再加上个人原因，学习进度有点停滞不前转载自B站 codesheep自己确实没时间学习和总结，能更新一次，顺便自己也过一遍知识体系","text":"今天转载一下java后端知识总结吧，由于这些天搬砖很累，再加上个人原因，学习进度有点停滞不前转载自B站 codesheep自己确实没时间学习和总结，能更新一次，顺便自己也过一遍知识体系 编程基础（掌握）JAVA语法Java基础JVM 类加载机制 字节码执行机制 JVM内存模型 GC垃圾回收 JVM性能监控与故障定位 JVM调优 多线程 并发编程的基础 线程池 锁 并发容器 原子类 JUC并发工具类数据结构和算法数据结构 字符串 数组 链表 堆、栈、队列 二叉树 哈希 图 算法 排序 查找 贪心 分治 动态规划 回溯计算机网络 ARP协议 IP、ICMP协议 TCP、UDP协议 DNS、HTTP/HTTPS协议 Session/CookieMySQL数据库 SQL语句的书写 SQL语句的优化 事务、隔离级别 索引 锁操作系统 进程、线程 并发、锁 内存管理和调度 I/O原理### 设计模式 单例 工厂 代理 策略 模板方法 观察者 适配器 责任链 建造者前端（了解） 基础套餐（大致了解，2-3天） 三大件 HTML JavaScript CSS 基础库 jQuery Ajax 模板框架 JSP/JSTL（已过时） Thymeleaf FreeMarker 组件化框架 Vue React Angular———————————————– 运维知识（配置） Web服务器 Nginx 应用服务器 Tomcat Jetty Undertow CDN加速 持续集成/持续部署 Jenkins 代码质量检查 sonar 日志收集和分析 ELK 成神之路 徒手撕源码 光脚造轮子 闭着眼睛深度调优 吊打面试官 平稳降落研发工具集成开发环境 Eclipse Intellij IDEA VSCode Linux系统（了解） 常用命令 Shell脚本### 项目管理/构建工具（掌握） Maven Gradle### 代码管理工具（了解） SVN Git","categories":[],"tags":[]},{"title":"憨憨的第一篇博客","slug":"憨憨的第一篇博客","date":"2020-08-24T08:59:45.000Z","updated":"2020-08-24T09:04:34.106Z","comments":true,"path":"2020/08/24/憨憨的第一篇博客/","link":"","permalink":"http://yoursite.com/2020/08/24/%E6%86%A8%E6%86%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"##开篇憨憨的第一篇博客今天是2020年8月24日今天试着搭建了自己的第一篇博客，很多天前就一直想着要搭建一下，自己自制力太差了，严重批评一下自己； 不知道这样的形式能不能坚持下去，很大程度上是为了学习更好的技术；似乎高考以后就再也没有写作的机会了，感觉是对写作这两个字的侮辱，那也叫写作？哈哈；其实我也不知道想写些什么，不如就记录一下我的生活吧；如果你能看到这段文字，非常幸运我们能够遇见，也感谢你能来到我的世界；","categories":[],"tags":[]}],"categories":[],"tags":[]}